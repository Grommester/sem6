<p>Password - clown123</p>
<h1>Введение</h1>
<p>теперь создайте на рабочем столе пустой документ и назовите его Hello.c. В нем напишите</p> 
```
# include <stdio.h>
void main ()
{
printf("Первая программма в Unix! \n");
}
```
<p>Откройте консоль и введите следующие команды ls (позволяет посмотреть, какие пап вам доступны), cd 'Рабочий стол' (позволяет перейти в папку, где лежит Ваш код), gcc Hello.c -o test (компилирует вашу программу в файл с именем test (имя можно менять). /test (запуск кода).
Ls (сокращение от list) вывод содержимого каталога. 
Команда, которая используется для движения по дереву каталогов, называется cd — сокращение от «change directory» («изменить каталог»).
GCC - GNU Compiler Collection - набор компиляторов и сопутствующих утилит, GCC входит в состав любого дистрибутива Linux и, как правило, устанавливается по умолчанию.
Теперь в каталоге с Hello.c отдадим команду</p>
```
$ gcc hello.c -o hello
```
<p>Появляется файл a.out</p>
```
$ ls
a.out hello.c
```
<p>Готовый файл нашей программы. По умолчанию gcc присваивает выходному исполняемому файлу имя a.out</p>
```
$ file a.out
```
<p>Запустим получившийся программный продукт:</p> 
```
$ ./a.out 
hello world
```
<p>(ЭВМ 1ГО поколения) 
1943 год бол.таблицы. Расчет 4го года. Балистические ракеты, расчет 4года.
Джон Эккер с Джонай Мокли разработали 1ый компьютер Эниак. В 1945 была закончина разработка 1го компа.Скорость одного расчета занимал 5 минут. Построен на лампах. 
Данные на перфокартах. 
перепрограммирование на переменных. 
Десятичное вычисление. </P

<p>(Архитектра фон Неймана.0 
Переход на 2ичыное вычисление. 1 = есть сигнал 0 = нету.
Память появляется. Вместо карт.
Память это ячейка. У процессора есть доступ к ячейке и её номеру. 
Коммвнды выполняются последовательно. 
(ЭВМ 2ГО ПОКОЛЕНИЯ) 
Первые языки программирования. 
Переход на транзисторы в 50х годах.</p>
<p>+ транзисторы не выделяют тепло</p>
<p>+ надежность, не перегорают. </p>
<p>+ большая скорость переключения. </p>
<p>+ удобная компоновка деталей.</p>
</p>
<p>- Плотная компоновка. Сложных ремонт
<p>- стоимость
<p>- шум
Появляются компиляторы. 
Языки = COBO. ALGOL
</p>

<p>(ЭВМ 3-4го поколения)</p>
<p>- Проблемы соединений</p>
<p>- изоляция элементов. </p>

<p>+ производствож</p>
<p>
(3Е ПОКОЛЕНИЕ) 
60-70е годы.
увел.быстродействи и надежность.
ускорение ввода. 
появление магнитного действия. 
Принцип появления разделения времени. 
(4ОЕ ПОКОЛЕНИЕ)
70-80х 
многозадачность 
виртуальная память. 
появление концепции баз данных. 
Размещение всех ИС на одном кристалле. 
Первый ПК Altair8800.
(BSD-UNIX) 
Вир.машина.
Система FFS
</p>
<p>
(Идеология UNIX) 
Пишит прог.которые делают все качественно 
Пишит прог.которые работают вместе
поддержка текст.потоки
</p>
<p>
(Абстракция архитектры) 
Польз.программы.
ядро.
Ассемблер.
Микрокод.
Аппаратно обеспечение.
</p>

<h1>Коммандная строка</h1>
<p>документацию можно прочитать, введя --help</p>
<p>Документация состоит из разделов</p>
<p>1. исполняемые программы</p>
<p>2. функции</p>
<p>3. библиотечные функции</p>
<p>4. специальные файлы</p>
<p>5. форматы файлов</p>
<p>6. игры</p>
<p>7. разное  (макросы и соглашения)</p>
<p>8. комманды администрирования</p>
<p>9. процедуры ядра</p>
<h3>Редатирование файлов</h3>
<p>less - постраничный просмотр и поиск</p>
<p>file, stst - информация о файле</p>
<p>readlink - получить полное имя файла</p>
<p>tail, head - просмотр конца и начала файла. Монитор логов</p>
<p>vi/vim, emacs, nano, mcedit - редактирование текста</p>
<p>split - разбить файл на несколько частей</p>
<h3>Файлы</h3>
<p>touch - создаёт файл, если он не существует</p>
<p>cp - копирование</p>
<p>mv - перемещение/переименование файла</p>
<p>ln - создаёт ссылки на файлы</p>
<p>alias - создаёт алиас для команды</p>
<h3>Удаление файлов</h3>
<p>cd - переход в указанную директорию: . - текущая; .. - дир одним уровнем иерархии выше</p>
<p>cd - - переходв предыдущую использованную директорию</p>
<p>ls - отображает содержимое директории</p>
<p>pwd - отображает текущую директорию</p>
<p>readlink - полный путь к файлу</p>
<h3>Права файлов</h3>
<p>-rwx</p>
<p>- обыйный файл, d директория, l ссылки, s сокеты, r чтение, w запись, x исполнение</p>
<h>Кто и икогда</h3>
<p>w - показывает, кто залогинен и чем занят</p>
<p>whe - показывает, кто залогинен</p>
<p>wall - отправляет сообщение на все терминалы</p>
<p>useradd - утилита создания пользователя</p>
<p>userdel - утилита удаление пользователя</p>
<p>usermod - у изменения аккаунтов</p>
<p>date - просмотр, установленной даты</p>
<p>cal, ncal - простой календарь</p>
<h3>Потоки ввода/вывода</h3>
<p>STDIN(0) - стандартный ввод</p>
<p>STDOUT(1) - стандартный вывод</p>
<p>STDERR(2) - стандартный поток ошибок</p>
<p> < - перенаправление ввода с клавы в файл</p>
<p> > - перенаправление выводас файл в командную строку</p>
<h1>Процессы</h1>
</p>процесс - обстрак.термин. Под ним понимаетмя набор ресурсов задачи во время выполнения. </p>
</p>1)Память</p>
</p>2) Дискриптор</p>
</p>3) Контекс выполнения</p>
</p>4) pid </p>
</p>5) обработчики сигналов</p>
</p>6) один поток, как минимум.</p>

<h3>Потоки имеют</h3>
<p>1)обш.вир.память</p>
<p>2) каждый свой вирт.процессор</p>
<p>Stack - Адреса возврата из подпрограмм(Аргументы функций)</p>
<p>mmap - Разделяемая библиотека</p>
<p>неиспользованная память </p>
<p>heap - Всякие локальные переменные и временные данные </p>
<p>bss - Неинициализированные и статические переменные </p>
<p>data - Иницициализированные и статические переменные </p>
<p>text - исполняемые инструкции (код)</p>

<p>Стек - переполнение чего-то там.</p>

<p>Виртуальная файловая система /proc</p>
<p>Pid/maps - карта памяти</p>
<p>Pid/fd - откр.файловые дескрипторы</p>
<p>Pid/enivorm - переменые окружения </p>
<p>Pid/exe - симлик на использ.файл </p>
<p>Pid/cwd симлик на деректорию </p>
<p>Pid/status  состояние процессора. </p>

 <h1>Жизненный цикл процесса</h1>
 
 Появление процесса в системе 
 1) Int - 1й процесс в системе
 2) функ.fork() - порождет новый процесс со всеми его атрибутами и ресурсами(сист.вызова clone())
 3) После вызова fork() и дочерний и родительский процессы продолжают работу с точки вызова fork()
 4) Дочернему процессу Fork() возвращает 0, родительскому - PID порожденного процесса.
 5) Дочерний процесс - полная копия родительского, за исключением PID. 
 6) Первым управление получает child
 7) Процесс и поток для ядра linux - одинаковые сущности. 
 8) Поток отличается только наличием разделяемых ресурсов. 
 
 (Copy-on-write)
 Адресное пространство родителя и порожденного процесса совместное
 Дубликат ресурсов создается только при попытке изменить данные
 Для создания потока используется тот же системный вызов clone()
 
 (Новый процесс: exec
 exec загружает бинарный файл в адресное пространство процесса 
 выполнение начинается с точки входа в программу 
 при выполнении сразу после fork() копирования страниц памяти и происходит
 
 (Смерть процесса )
 1) Процесс заканчивается системным вызовом exit() либо сигналом завершения
 2) Сигнал процессу можно отправить командой kill 
 3) После завершения дочерний процесс находитс в состоянии зомби
 4) Если род.процесс завершился раньше дочернего родительским становится либо другой потом
 
 (Состояния процесса: Ready) 
 1) (R) процесс готов к выполнению 
 2) Ждет выделения процессорного времени планировщиком в очереди 
 3) Среднюю очередь ожидающих процессор процессов показывает Load average
 
 (Состояние процесса: Остановлен )
 1) Остановлен - процесс прекращает работу до получение сигнала SIGCONT
 2) Используют транссировщики 
 3) Сочетание клавишь CTRL+Z или сигнал SIGSTOP отправляет процесс в это состояние 
 
 (Состояние процесса: Sleeping) 
 1) Sleeping - процесс ожидании
 2) Вызов функции sleep() отправляет процесс в состоянии S 
 3) Как только ресурс доступен - процесс переходит в состояние READY или Running 
